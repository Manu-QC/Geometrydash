<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash - Stereo Madness</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pusab:wght@400;700&display=swap');
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #87CEEB;
            color: #fff;
            font-family: 'Pusab', Arial, sans-serif;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            border: 4px solid #000;
            background: #87CEEB;
        }

        #gameCanvas {
            background: #87CEEB;
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.3);
            z-index: 5;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff8000, #ff0000);
            width: 0%;
            transition: width 0.1s ease;
        }

        .level-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .controls-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #fff;
            font-size: 12px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }

        .retry-btn {
            background: #00ff00;
            border: 3px solid #000;
            color: #000;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            border-radius: 5px;
            font-family: 'Pusab', Arial, sans-serif;
        }

        .retry-btn:hover {
            background: #40ff40;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div class="ui-overlay">
            <div style="font-size: 18px; font-weight: bold;">Stereo Madness</div>
            <div style="font-size: 14px;" id="attemptCounter">Attempt 1</div>
            <div style="font-size: 14px;" id="percentDisplay">0%</div>
        </div>

        <div class="level-info">
            <div>Normal Level</div>
            <div>★★★☆☆☆☆☆☆☆</div>
        </div>

        <div class="controls-info">
            <div>SPACE / CLICK to Jump</div>
            <div>HOLD to continuously jump</div>
        </div>

        <div class="game-over-screen" id="gameOverScreen">
            <h2 style="color: #ff4444; font-size: 48px; margin-bottom: 20px;">Level Failed!</h2>
            <div style="font-size: 24px; margin-bottom: 30px;" id="finalPercent">0% Complete</div>
            <button class="retry-btn" onclick="restartLevel()">Try Again</button>
            <button class="retry-btn" onclick="location.reload()">Main Menu</button>
        </div>
    </div>

    <audio id="stereoMadnessMusic" loop>
        <!-- Stereo Madness Music - Replace with actual file -->
        <source src="https://www.dropbox.com/s/example/stereo-madness.mp3" type="audio/mpeg">
        <!-- Fallback music with similar BPM -->
        <source src="https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-14854.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Game variables
        let gameSpeed = 5.77; // Exact speed of Stereo Madness
        let cameraX = 0;
        let gameTime = 0;
        let attempts = 1;
        let levelProgress = 0;
        let gameRunning = true;
        let spacePressed = false;

        // Player (cube)
        const player = {
            x: 100,
            y: canvas.height - 150,
            size: 30,
            velY: 0,
            jumping: false,
            onGround: true,
            rotation: 0,
            color: "#FFD700", // Golden yellow like default cube
            trail: []
        };

        // Physics
        const gravity = 0.6;
        const jumpForce = -13;
        const groundY = canvas.height - 120;

        // Level data - Stereo Madness pattern
        const levelData = [
            // Start area (cubes and spikes)
            {type: 'spike', x: 400, y: groundY},
            {type: 'cube', x: 500, y: groundY - 30},
            {type: 'spike', x: 600, y: groundY},
            {type: 'spike', x: 650, y: groundY},
            {type: 'cube', x: 750, y: groundY - 30},
            {type: 'cube', x: 780, y: groundY - 60},
            
            // First challenging section
            {type: 'spike', x: 900, y: groundY},
            {type: 'cube', x: 1000, y: groundY - 30},
            {type: 'spike', x: 1100, y: groundY},
            {type: 'cube', x: 1200, y: groundY - 60},
            {type: 'spike', x: 1300, y: groundY},
            {type: 'spike', x: 1350, y: groundY},
            {type: 'cube', x: 1450, y: groundY - 30},
            
            // Mid section with platforms
            {type: 'platform', x: 1600, y: groundY - 90, width: 90},
            {type: 'spike', x: 1720, y: groundY - 90},
            {type: 'cube', x: 1800, y: groundY - 30},
            {type: 'platform', x: 1950, y: groundY - 60, width: 60},
            {type: 'spike', x: 2040, y: groundY - 60},
            
            // Staircase section
            {type: 'cube', x: 2200, y: groundY - 30},
            {type: 'cube', x: 2230, y: groundY - 60},
            {type: 'cube', x: 2260, y: groundY - 90},
            {type: 'spike', x: 2320, y: groundY - 90},
            {type: 'cube', x: 2400, y: groundY - 60},
            {type: 'cube', x: 2430, y: groundY - 30},
            
            // Final challenging area
            {type: 'spike', x: 2600, y: groundY},
            {type: 'cube', x: 2700, y: groundY - 90},
            {type: 'spike', x: 2800, y: groundY},
            {type: 'spike', x: 2850, y: groundY},
            {type: 'cube', x: 2950, y: groundY - 30},
            {type: 'platform', x: 3100, y: groundY - 120, width: 120},
            {type: 'spike', x: 3250, y: groundY - 120},
            
            // End section
            {type: 'cube', x: 3400, y: groundY - 30},
            {type: 'spike', x: 3500, y: groundY},
            {type: 'end', x: 3700, y: groundY}
        ];

        const levelLength = 3800; // Total level length

        function drawBackground() {
            // Sky blue background
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Clouds (simple white circles)
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            for (let i = 0; i < 10; i++) {
                const cloudX = (i * 400 - cameraX * 0.3) % (canvas.width + 200);
                const cloudY = 50 + Math.sin(i) * 30;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 30, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, cloudY, 25, 0, Math.PI * 2);
                ctx.arc(cloudX + 50, cloudY, 30, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ground
            ctx.fillStyle = "#228B22"; // Forest green
            ctx.fillRect(-cameraX, groundY, levelLength + canvas.width, canvas.height - groundY);
            
            // Ground pattern (grass texture)
            ctx.fillStyle = "#32CD32";
            for (let x = -cameraX; x < levelLength + canvas.width; x += 60) {
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(x + i * 12, groundY + i * 2, 8, 15);
                }
            }
        }

        function drawPlayer() {
            ctx.save();
            
            // Player trail
            ctx.globalAlpha = 0.3;
            player.trail.forEach((point, i) => {
                const alpha = i / player.trail.length;
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillStyle = player.color;
                ctx.fillRect(point.x - cameraX - 2, point.y - 2, 4, 4);
            });
            ctx.globalAlpha = 1;
            
            // Main player cube
            ctx.translate(player.x - cameraX + player.size/2, player.y + player.size/2);
            ctx.rotate(player.rotation);
            
            // Cube body
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
            
            // Cube border
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size);
            
            // Cube face details
            ctx.fillStyle = "#FFF";
            ctx.fillRect(-player.size/2 + 5, -player.size/2 + 5, player.size - 10, player.size - 10);
            ctx.fillStyle = "#000";
            ctx.fillRect(-player.size/2 + 8, -player.size/2 + 8, player.size - 16, player.size - 16);
            
            ctx.restore();
        }

        function drawObstacles() {
            levelData.forEach(obstacle => {
                if (obstacle.x - cameraX > canvas.width + 100 || obstacle.x - cameraX < -100) return;
                
                ctx.save();
                
                switch(obstacle.type) {
                    case 'spike':
                        // Draw spike
                        ctx.fillStyle = "#FF4444";
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x - cameraX, obstacle.y);
                        ctx.lineTo(obstacle.x - cameraX + 15, obstacle.y - 30);
                        ctx.lineTo(obstacle.x - cameraX + 30, obstacle.y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                        
                    case 'cube':
                        // Draw cube obstacle
                        ctx.fillStyle = "#4444FF";
                        ctx.fillRect(obstacle.x - cameraX, obstacle.y, 30, 30);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(obstacle.x - cameraX, obstacle.y, 30, 30);
                        
                        // Cube highlight
                        ctx.fillStyle = "#6666FF";
                        ctx.fillRect(obstacle.x - cameraX + 3, obstacle.y + 3, 24, 24);
                        break;
                        
                    case 'platform':
                        // Draw platform
                        ctx.fillStyle = "#8B4513";
                        ctx.fillRect(obstacle.x - cameraX, obstacle.y, obstacle.width, 30);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x - cameraX, obstacle.y, obstacle.width, 30);
                        break;
                        
                    case 'end':
                        // End portal
                        ctx.fillStyle = "#00FF00";
                        ctx.fillRect(obstacle.x - cameraX, obstacle.y - 90, 60, 90);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(obstacle.x - cameraX, obstacle.y - 90, 60, 90);
                        
                        // Portal effect
                        ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
                        for (let i = 0; i < 5; i++) {
                            ctx.fillRect(obstacle.x - cameraX + i * 12, obstacle.y - 90, 3, 90);
                        }
                        break;
                }
                
                ctx.restore();
            });
        }

        function updatePlayer() {
            // Gravity
            if (!player.onGround) {
                player.velY += gravity;
                player.rotation += 6; // Rotate while in air
            } else {
                player.rotation = Math.round(player.rotation / 90) * 90; // Snap to 90° increments
            }
            
            player.y += player.velY;
            
            // Ground collision
            if (player.y >= groundY - player.size) {
                player.y = groundY - player.size;
                player.velY = 0;
                player.onGround = true;
                player.jumping = false;
            }
            
            // Platform collision
            levelData.forEach(obstacle => {
                if (obstacle.type === 'platform') {
                    if (player.x + player.size > obstacle.x && 
                        player.x < obstacle.x + obstacle.width &&
                        player.y + player.size > obstacle.y &&
                        player.y + player.size < obstacle.y + 40 &&
                        player.velY > 0) {
                        player.y = obstacle.y - player.size;
                        player.velY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            });
            
            // Update trail
            player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 10) player.trail.shift();
        }

        function checkCollisions() {
            levelData.forEach(obstacle => {
                if (obstacle.type === 'spike' || obstacle.type === 'cube') {
                    if (player.x + player.size > obstacle.x + 5 && 
                        player.x < obstacle.x + 25 &&
                        player.y + player.size > obstacle.y - (obstacle.type === 'spike' ? 30 : 0) &&
                        player.y < obstacle.y + 30) {
                        gameOver();
                    }
                } else if (obstacle.type === 'end') {
                    if (player.x > obstacle.x) {
                        levelComplete();
                    }
                }
            });
        }

        function jump() {
            if (player.onGround && !player.jumping) {
                player.velY = jumpForce;
                player.onGround = false;
                player.jumping = true;
            }
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('finalPercent').textContent = Math.floor(levelProgress) + '% Complete';
        }

        function levelComplete() {
            gameRunning = false;
            alert('¡Nivel Completado! ¡Felicidades!');
            location.reload();
        }

        function restartLevel() {
            // Reset all game variables
            player.x = 100;
            player.y = canvas.height - 150;
            player.velY = 0;
            player.onGround = true;
            player.jumping = false;
            player.rotation = 0;
            player.trail = [];
            
            cameraX = 0;
            gameTime = 0;
            levelProgress = 0;
            gameRunning = true;
            attempts++;
            
            document.getElementById('attemptCounter').textContent = 'Attempt ' + attempts;
            document.getElementById('gameOverScreen').style.display = 'none';
        }

        function updateCamera() {
            // Follow player with offset
            const targetX = player.x - 200;
            cameraX += (targetX - cameraX) * 0.1;
            
            // Clamp camera
            if (cameraX < 0) cameraX = 0;
            if (cameraX > levelLength - canvas.width) cameraX = levelLength - canvas.width;
        }

        function updateUI() {
            levelProgress = (player.x / levelLength) * 100;
            document.getElementById('progressFill').style.width = levelProgress + '%';
            document.getElementById('percentDisplay').textContent = Math.floor(levelProgress) + '%';
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update
            updatePlayer();
            updateCamera();
            checkCollisions();
            updateUI();
            
            // Move player forward
            player.x += gameSpeed;
            gameTime++;
            
            // Draw
            drawBackground();
            drawObstacles();
            drawPlayer();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        let isHolding = false;

        document.addEventListener('keydown', (e) => {
            if ((e.code === 'Space' || e.code === 'ArrowUp') && !spacePressed) {
                e.preventDefault();
                jump();
                spacePressed = true;
                isHolding = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                spacePressed = false;
                isHolding = false;
            }
        });

        canvas.addEventListener('mousedown', () => {
            jump();
            isHolding = true;
        });

        canvas.addEventListener('mouseup', () => {
            isHolding = false;
        });

        // Continuous jumping while holding
        setInterval(() => {
            if (isHolding && gameRunning) {
                jump();
            }
        }, 100);

        // Start game
        gameLoop();

        // Try to play music (user interaction required)
        document.addEventListener('click', () => {
            const music = document.getElementById('stereoMadnessMusic');
            music.play().catch(e => console.log('Music requires user interaction'));
        }, { once: true });
    </script>
</body>
</html>